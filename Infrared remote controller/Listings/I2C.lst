C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Objects\I2C.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE module\I2C.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\common;.\module
                    -) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\Listings\I2C.lst) TABS(2) OBJECT(.\Objects\I2C.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2016 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Nuvoton Technoledge Corp. 
   9          //  Website: http://www.nuvoton.com
  10          //  E-Mail : MicroC-8bit@nuvoton.com
  11          //  Date   : Apr/21/2016
  12          //********************************************************************************************************
             -***
  13          
  14          //********************************************************************************************************
             -***
  15          //  File Function: N76E003 I2C demo code, Slave Address of 24LC64 = 0xA0
  16          //
  17          //   ____________           ______________ 
  18          //  |            |   SDA    |             |
  19          //  |            |<-------->|             |
  20          //  |            |          |             |
  21          //  |N76E003(M) |          |   24LC64(S) |
  22          //  |            |   SCL    |             |
  23          //  |            |--------->|             |
  24          //  |____________|          |_____________|
  25          //
  26          //  Microchip I2C EEPROM 24xx64 (64K Bit) is used as the slave device.  
  27          //  The page size are 32Byte. Total are 256 page.
  28          //  If verification passes, Port3 will show 0x78. If there is any failure
  29          //  occured during the progress, Port3 will show 0x00.
  30          //********************************************************************************************************
             -***
  31          
  32          #include <stdio.h>
  33          #include "N76E003.h"
  34          #include "Define.h"
  35          #include "Common.h"
  36          #include "Delay.h"
  37          #include "SFR_Macro.h"
  38          #include "Function_define.h"
  39          #include  "I2C.h"
  40          
  41          //#define SYS_CLK_EN              0
  42          //#define SYS_SEL                 2
  43          //#define SYS_DIV_EN              0                   //0: Fsys=Fosc, 1: Fsys = Fosc/(2*CKDIV)
  44          //#define SYS_DIV                 1
  45          //#define I2C_CLOCK               159                 //25kbps 
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 2   

  46          
  47          //#define EEPROM_SLA              0xe6
  48          //#define EEPROM_WR               0
  49          //#define EEPROM_RD               1
  50          
  51          //#define LED                     P3
  52          //#define PAGE_SIZE               32
  53          //#define PAGE_NUMBER             4
  54          
  55          //#define ERROR_CODE              0x78
  56          //#define TEST_OK                 0x00
  57          
  58          //定义端口
  59          //sbit      SDA_I2C_FM1602LF        = P0^6; //RS为寄存器选择，高电平时选择数据寄存器、低电平时选择指令寄存器。
  60          //sbit      SCL_I2C_FM1602LF        = P0^5; //R/W为读写信号线，高电平时进行读操作，低电平时进行写操作。
  61          //sbit      SCL_I2C_NPCA110P        = P0^4;
  62          //sbit      SDA_I2C_NPCA110P        = P0^3;
  63          sbit      SCL_I2C                 = P0^4;
  64          sbit      SDA_I2C                 = P0^3;
  65          
  66          //EX_extern void  delay(void);
  67          //EX_extern void start_I2C(void);
  68          //EX_extern void respons_I2C(void);
  69          //EX_extern void stop_I2C(void);
  70          //EX_extern void writebyte_I2C(UINT8 data_I2C);
  71          //EX_extern UINT8 readbyte_I2C(void);
  72          //EX_extern void I2C_Error(void);
  73          
  74          //EX_extern void writebyte_I2C_add(UINT8 address,UINT8 data_I2C);
  75          //EX_extern UINT8 readbyte_I2C_add(UINT8 address);
  76          //EX_extern void One_Page_Read(UINT8 u8PageNumber,UINT8 u8DAT);
  77          //EX_extern void One_Page_Write(UINT8 u8PageNumber,UINT8 u8DAT);
  78          
  79          //========================================================================================================
  80          void  delay(void)
  81          {
  82   1          UINT16 i = 0;
  83   1          for(i=0;i<50;i++);
  84   1      //    Timer1_Delay10us(1);
  85   1      }
  86          
  87          //========================================================================================================
  88          void I2C_Error(void)
  89          {
  90   1      //    P3 = I2STAT;
  91   1      //    P3 = ERROR_CODE;
  92   1          while (1)P12 = 0;    
  93   1      }
  94          
  95          void Init_I2C(void)
  96          {
  97   1          SCL_I2C = 1;                                //set SDA and SCL pins high
  98   1          delay();
  99   1          SDA_I2C = 1;
 100   1          delay();
 101   1      }
 102          //========================================================================================================
 103          void start_I2C(void)
 104          {
 105   1          SDA_I2C = 1;
 106   1          delay();
 107   1          SCL_I2C = 1; 
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 3   

 108   1          delay();
 109   1          SDA_I2C = 0;
 110   1          delay();
 111   1      }
 112          
 113          //========================================================================================================
 114          void respons_I2C(void)
 115          {
 116   1          UINT16 i = 0;
 117   1          delay();
 118   1          delay();
 119   1          delay();
 120   1          delay();
 121   1          SCL_I2C = 1;
 122   1          delay();
 123   1          while((SDA_I2C == 1)&&(i<10))
 124   1          {
 125   2              delay();
 126   2              i++;
 127   2              if(i==10)
 128   2              {
 129   3                  I2C_Error();
 130   3              }
 131   2          }
 132   1          SCL_I2C = 0;
 133   1          delay();
 134   1          delay();
 135   1          delay();
 136   1          delay();
 137   1          delay();
 138   1      }
 139          
 140          //========================================================================================================
 141          void stop_I2C(void)
 142          {
 143   1          SDA_I2C = 0;
 144   1          delay();
 145   1          SCL_I2C = 1;
 146   1          delay();
 147   1          SDA_I2C = 1;
 148   1          delay();
 149   1      }
 150          
 151          void writebyte_I2C(UINT8 data_I2C)
 152          {
 153   1          UINT8 i,temp;
 154   1          temp = data_I2C;
 155   1          for(i = 0;i < 8;i++)
 156   1          {
 157   2              SCL_I2C = 0;
 158   2              delay();
 159   2              if(temp&0x80)
 160   2              {
 161   3                  SDA_I2C = 1;
 162   3              }
 163   2              else
 164   2              {
 165   3                  SDA_I2C = 0;
 166   3              }
 167   2              temp = temp << 1;
 168   2              delay();
 169   2              delay();
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 4   

 170   2              delay();
 171   2              //delay();
 172   2              SCL_I2C = 1;
 173   2              delay();
 174   2          }
 175   1          SCL_I2C = 0;
 176   1          delay();
 177   1          SDA_I2C = 1;
 178   1          delay();
 179   1      }
 180          
 181          UINT8 readbyte_I2C(void)
 182          {
 183   1          UINT8 i,k;
 184   1          SCL_I2C = 0;
 185   1          delay();
 186   1          SDA_I2C = 1;
 187   1          delay();
 188   1          for(i = 0;i < 8;i++)
 189   1          {
 190   2              SCL_I2C = 1;
 191   2              delay();
 192   2              k = (k << 1)| SDA_I2C;
 193   2              SCL_I2C = 0;
 194   2              delay();
 195   2          }
 196   1          delay();
 197   1          return k;
 198   1      }
 199          
 200          
 201          //========================================================================================================
 202          //void Init_I2C1(void)
 203          //{
 204          //  #if 0
 205          //    /* Set I2C clock rate */
 206          ////    I2CLK = I2C_CLOCK; 
 207          
 208          ////    /* Enable I2C */
 209          ////    set_I2CEN;     
 210          //  #endif
 211          ////    P13_Quasi_Mode;                         //set SCL (P13) is Quasi mode
 212          ////    P14_Quasi_Mode;                         //set SDA (P14) is Quasi mode
 213          ////    I2CPX = 0;
 214          //    P03_OpenDrain_Mode;
 215          //    P04_OpenDrain_Mode;
 216          //    SCL_I2C = 1;                                //set SDA and SCL pins high
 217          //    delay();
 218          //    SDA_I2C = 1;
 219          //    delay();
 220          //    
 221          ////    set_P0SR_6;                             //set SCL (P06) is  Schmitt triggered input select.
 222          ////    
 223          ////    set_EI2C;                               //enable I2C interrupt by setting IE1 bit 0
 224          ////    set_EA;
 225          
 226          ////    I2ADDR = EEPROM_SLA;                    //define own slave address
 227          ////    set_I2CEN;                              //enable I2C circuit
 228          ////    set_AA;
 229          //}
 230          
 231          
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 5   

 232          //void writebyte_I2C1_one(UINT8 data_I2C)
 233          //{
 234          //    start_I2C();
 235          //    writebyte_I2C(EEPROM_SLA|EEPROM_WR);
 236          //    respons_I2C();
 237          //    writebyte_I2C(data_I2C);
 238          //    respons_I2C();
 239          //    stop_I2C();
 240          //}
 241          
 242          //void writebyte_I2C1_many(UINT8 number,UINT8 *data_I2C)
 243          //{
 244          //    UINT8 i=0;
 245          //    start_I2C();
 246          //    writebyte_I2C(EEPROM_SLA|EEPROM_WR);
 247          //    respons_I2C();
 248          //    for(i=0;i<number;i++)
 249          //    {
 250          //        writebyte_I2C(*data_I2C++);
 251          //        respons_I2C();
 252          //    }
 253          //    stop_I2C();
 254          //}
 255          //void writebyte_I2C1_add(UINT8 address,UINT8 data_I2C)
 256          //{
 257          //    start_I2C();
 258          //    writebyte_I2C(EEPROM_SLA|EEPROM_WR);
 259          //    respons_I2C();
 260          //    writebyte_I2C(address);
 261          //    respons_I2C();
 262          //    writebyte_I2C(data_I2C);
 263          //    respons_I2C();
 264          //    stop_I2C();
 265          //}
 266          
 267          //UINT8 readbyte_I2C1_add(UINT8 address)
 268          //{
 269          //    UINT8 data_I2C;
 270          //    start_I2C();
 271          //    writebyte_I2C(0xe7);
 272          //    respons_I2C();
 273          //    writebyte_I2C(address);
 274          //    respons_I2C();
 275          //    writebyte_I2C(0xe6);
 276          //    respons_I2C();
 277          //    data_I2C = readbyte_I2C();
 278          //    stop_I2C();
 279          //    return  data_I2C;
 280          //}
 281          
 282          //========================================================================================================
 283          //void Init_I2C(void)
 284          //{
 285          ////    /* Set I2C clock rate */
 286          //    P13_OpenDrain_Mode;
 287          //    P14_OpenDrain_Mode;
 288          //    I2CPX = 0;
 289          //    I2CLK = I2C_CLOCK; 
 290          //    /* Enable I2C */
 291          //    set_I2CEN;                                   
 292          //}
 293          //========================================================================================================
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 6   

 294          
 295          #if 0
              //========================================================================================================
              void One_Page_Read(UINT8 u8PageNumber,UINT8 u8DAT)
              {
                  UINT8  u8Count;
                  UINT16 u16Address;
              
                  u16Address = (UINT16)u8PageNumber*32;
              
                  /* Step1 */
                  set_STA;                                /* Send Start bit to I2C EEPROM */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x08)                     /* 0x08:  A START condition has been transmitted*/
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send STA' error");
                      while (1);
                  }
              
                  /* Step2 */
                  I2DAT = (EEPROM_SLA | EEPROM_WR);       /* Send (SLA+W) to EEPROM */
                  clr_STA;                                /* Clear STA and Keep SI value in I2CON */    
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x18)                     /* 0x18: SLA+W has been transmitted; ACK has been received */ 
             -             
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send SLA+W' error");
                      while(1);
                  }
              
                  /* Step3 */
                  I2DAT = HIBYTE(u16Address);             /* Send I2C EEPROM's High Byte Address */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */              
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send I2C High Byte Address' error");
                      while (1);
                  }
              
                  /* Step4 */
                  I2DAT = LOBYTE(u16Address);             /* Send I2C EEPROM's Low Byte Address */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */             
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send I2C Low Byte Address' error");
                      while (1);
                  }
              
                  /* Step5 */
                  set_STA;                                /* Repeated START */
                  clr_SI; 
                  while (!SI);
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 7   

                  if (I2STAT != 0x10)                     /* 0x10: A repeated START condition has been transmitted */
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send STA' error");
                      while (1);
                  }
              
                  /* Step6 */
                  clr_STA;                                /* Clear STA and Keep SI value in I2CON */
                  I2DAT = (EEPROM_SLA | EEPROM_RD);       /* Send (SLA+R) to EEPROM */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x40)                     /* 0x40:  SLA+R has been transmitted; ACK has been received */
             -              
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send SLA+R' error");
                      while (1);
                  }
              
                  /* Step7 */                             /* Verify I2C EEPROM data */
                  for (u8Count = 0; u8Count <PAGE_SIZE; u8Count++)
                  {
                      set_AA;                             /* Set Assert Acknowledge Control Bit */
                      clr_SI;
                      while (!SI);
                      if (I2STAT != 0x50)                 /* 0x50:Data byte has been received; NOT ACK has been returned
             - */              
                      {
                          LED = ERROR_CODE;
                          printf("\nI2C 'No Ack' error");
                          while (1);
                      }
                     
                      if (I2DAT != u8DAT)                 /* Send the Data to EEPROM */    
                      {
                          LED = ERROR_CODE;
                          printf("\nI2C 'Read data' error");
                          while (1);
                      }
                      u8DAT = ~u8DAT; 
                  }
              
                  /* Step8 */
                  clr_AA;                                 /* Send a NACK to disconnect 24xx64 */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x58)                     /* 0x58:Data byte has been received; ACK has been returned */
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Ack' error");
                      while (1);
                  }
                  
                  /* Step9 */    
                  clr_SI;
                  set_STO;
                  while (STO);                            /* Check STOP signal */ 
              }
              //========================================================================================================
              void One_Page_Write(UINT8 u8PageNumber,UINT8 u8DAT)
              {
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 8   

                  UINT8  u8Count;
                  UINT16 u16Address;
              
                  u16Address = (UINT16)u8PageNumber*32;
              
                  /* Step1 */
                  set_STA;                                /* Send Start bit to I2C EEPROM */         
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x08)                     /* 0x08:  A START condition has been transmitted*/
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send STA' error");
                      while (1);
                  }
              
                  /* Step2 */
                  clr_STA;                                /* Clear STA and Keep SI value in I2CON */
                  I2DAT = EEPROM_SLA | EEPROM_WR;         /* Send (SLA+W) to EEPROM */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x18)                     /* 0x18: SLA+W has been transmitted; ACK has been received */ 
             -            
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send SLA+W' error");
                      while (1);
                  }
              
                  /* Step3 */
                  I2DAT = HIBYTE(u16Address);             /* Send EEPROM's High Byte Address */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send High byte address' error");
                      while (1);
                  }
              
                  /* Step4 */
                  I2DAT = LOBYTE(u16Address);             /* Send EEPROM's Low Byte Address */
                  clr_SI;
                  while (!SI);
                  if (I2STAT != 0x28)                     /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */
                  {
                      LED = ERROR_CODE;
                      printf("\nI2C 'Send Low byte address' error");
                      while (1);
                  }
              
                  /* Step5 */
                                                          /* Write data to I2C EEPROM */
                  for (u8Count = 0; u8Count < PAGE_SIZE; u8Count++)
                  {
                      I2DAT = u8DAT;                      /* Send data to EEPROM */
                      clr_SI;
                      while (!SI);
                      if (I2STAT != 0x28)                 /* 0x28:  Data byte in S1DAT has been transmitted; ACK has bee
             -n received */
C51 COMPILER V9.00   I2C                                                                   03/25/2017 17:07:57 PAGE 9   

                      {
                          LED = ERROR_CODE;
                          printf("\nI2C 'Write Data' error");
                          while (1);
                      }   
                      u8DAT = ~u8DAT;        
                  }
                                                          //After STOP condition, a inner EEPROM timed-write-cycle 
                                                          //will occure and EEPROM will not response to outside command
                                                          /* 0x18: SLA+W has been transmitted; ACK has been received */
                  /* Step6 */
                  do
                  {
                      set_STO;                            /* Set I2C STOP Control Bit */
                      clr_SI;
                      while (STO);                        /* Check STOP signal */
                      
                      set_STA;                            /* Check if no ACK is returned by EEPROM, it is under timed-wr
             -ite cycle */
                      clr_SI;
                      while (!SI);
                      if (I2STAT != 0x08)                 /* 0x08:  A START condition has been transmitted*/
                      {
                          LED = ERROR_CODE;
                          printf("\nI2C 'Wait Ready' error");
                          while (1);
                      }
              
                      clr_STA;                            /* Clear STA and Keep SI value in I2CON */
                      I2DAT = (EEPROM_SLA | EEPROM_WR);   /* Send (SLA+W) to EEPROM */
                      clr_SI;
                      while (!SI);
                  }while(I2STAT != 0x18);
              
                  /* Step7 */
                  set_STO;                                /* Set STOP Bit to I2C EEPROM */
                  clr_SI;
                  while (STO);                            /* Check STOP signal */
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    205    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
